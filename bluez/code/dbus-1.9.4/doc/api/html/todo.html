<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>D-Bus: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">D-Bus
   &#160;<span id="projectnumber">1.9.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000060"></a>Global <a class="el" href="group__DBusSysdeps.html#ga095c54de3974c6d04c29ef86c6e06e35">_dbus_append_user_from_current_process</a>  (<a class="el" href="structDBusString.html">DBusString</a> *str)</dt>
<dd>to which class belongs this  </dd>
<dt><a class="anchor" id="_todo000005"></a>Global <a class="el" href="group__DBusAuth.html#ga7eb40f71c0ede79f954bcb2c001c8502">_dbus_auth_decode_data</a>  (<a class="el" href="structDBusAuth.html" title="Internal members of DBusAuth. ">DBusAuth</a> *auth, const <a class="el" href="structDBusString.html">DBusString</a> *encoded, <a class="el" href="structDBusString.html">DBusString</a> *plaintext)</dt>
<dd>1.0? We need to be able to distinguish "out of memory" error from "the data is hosed" error. </dd>
<dt><a class="anchor" id="_todo000062"></a>Global <a class="el" href="group__DBusSysdeps.html#ga701f9b3087c196404f66ff95b4ace0b8">_dbus_close_socket</a>  (int fd, <a class="el" href="structDBusError.html" title="Object representing an exception. ">DBusError</a> *error)</dt>
<dd>Use for the file descriptors a struct<ul>
<li>struct DBusSocket{ int d; }; - instead of int to get type-safety which will be checked by the compiler. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000058"></a>Global <a class="el" href="group__DBusSysdeps.html#gae3a3fdc0c6001e367584bb016aca495d">_dbus_concat_dir_and_file</a>  (<a class="el" href="structDBusString.html">DBusString</a> *dir, const <a class="el" href="structDBusString.html">DBusString</a> *next_component)</dt>
<dd>it might be cute to collapse multiple '/' such as "foo//" concat "//bar" </dd>
<dt><a class="anchor" id="_todo000008"></a>Global <a class="el" href="group__DBusConnectionInternals.html#gad5e725e66dc16a411544e25675fb9fba">_dbus_connection_block_pending_call</a>  (<a class="el" href="structDBusPendingCall.html" title="Implementation details of DBusPendingCall - all fields are private. ">DBusPendingCall</a> *pending)</dt>
<dd>could use performance improvements (it keeps scanning the whole message queue for example) </dd>
<dt><a class="anchor" id="_todo000007"></a>Global <a class="el" href="group__DBusConnectionInternals.html#ga12756797bd5c1918aa065f9c37ed7bba">_dbus_connection_handle_watch</a>  (<a class="el" href="structDBusWatch.html" title="Implementation of DBusWatch. ">DBusWatch</a> *watch, unsigned int condition, void *data)</dt>
<dd>This is basically a hack - we could delete <a class="el" href="group__DBusTransport.html#ga4a010098fe079eb6f201ff034d15fdff" title="Handles a watch by reading data, writing data, or disconnecting the transport, as appropriate for the...">_dbus_transport_handle_watch()</a> and the virtual handle_watch in <a class="el" href="structDBusTransport.html" title="Object representing a transport such as a socket. ">DBusTransport</a> if we got rid of it. The reason this is some work is threading, see the <a class="el" href="group__DBusConnectionInternals.html#ga12756797bd5c1918aa065f9c37ed7bba" title="A callback for use with dbus_watch_new() to create a DBusWatch. ">_dbus_connection_handle_watch()</a> implementation. </dd>
<dt><a class="anchor" id="_todo000067"></a>Global <a class="el" href="group__DBusSysdeps.html#gacecdbb00a3c8b63e821edae537ae3c7b">_dbus_credentials_add_from_user</a>  (<a class="el" href="structDBusCredentials.html">DBusCredentials</a> *credentials, const <a class="el" href="structDBusString.html">DBusString</a> *username)</dt>
<dd>this is broken because it treats OOM and parse error the same way. Needs a <a class="el" href="structDBusError.html" title="Object representing an exception. ">DBusError</a>. </dd>
<dt><a class="anchor" id="_todo000061"></a>Global <a class="el" href="group__DBusSysdeps.html#ga2212aa0e5732257598a6597748c658e4">_dbus_error_from_errno</a>  (int error_number)</dt>
<dd>should cover more errnos, specifically those from open(). </dd>
<dt><a class="anchor" id="_todo000013"></a>Global <a class="el" href="group__DBusKeyring.html#ga5bbeeef1ba831a89d7f0f211e886e7c2">_dbus_keyring_validate_context</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *context)</dt>
<dd>this is the most inefficient implementation imaginable. </dd>
<dt><a class="anchor" id="_todo000040"></a>Global <a class="el" href="group__DBusMessageInternals.html#gae77f064b8034189a955d5be982d2fbdb">_dbus_message_loader_get_buffer</a>  (<a class="el" href="structDBusMessageLoader.html" title="Implementation details of DBusMessageLoader. ">DBusMessageLoader</a> *loader, <a class="el" href="structDBusString.html">DBusString</a> **buffer)</dt>
<dd><p class="startdd">this function can be a lot more clever. For example it can probably always return a buffer size to read exactly the body of the next message, thus avoiding any memory wastage or reallocs.</p>
<p class="enddd">we need to enforce a max length on strings in header fields. </p>
</dd>
<dt><a class="anchor" id="_todo000042"></a>Global <a class="el" href="group__DBusMessageInternals.html#gaf55885371a6d022ec94c79bd7138923f">_dbus_message_loader_queue_messages</a>  (<a class="el" href="structDBusMessageLoader.html" title="Implementation details of DBusMessageLoader. ">DBusMessageLoader</a> *loader)</dt>
<dd><p class="startdd">we need to check that the proper named header fields exist for each message type.</p>
<p class="enddd">If a message has unknown type, we should probably eat it right here rather than passing it out to applications. However it's not an error to see messages of unknown type. </p>
</dd>
<dt><a class="anchor" id="_todo000044"></a>Global <a class="el" href="group__DBusObjectTree.html#gad660d78a12fa207d891838863dfc6ba7">_dbus_object_tree_dispatch_and_unlock</a>  (<a class="el" href="structDBusObjectTree.html" title="Internals of DBusObjectTree. ">DBusObjectTree</a> *tree, <a class="el" href="structDBusMessage.html" title="Internals of DBusMessage. ">DBusMessage</a> *message, dbus_bool_t *found_object)</dt>
<dd>thread problems </dd>
<dt><a class="anchor" id="_todo000047"></a>Global <a class="el" href="group__DBusString.html#ga4701fa3fabccad3ba64b7bf17c4ae14c">_dbus_string_ends_with_c_str</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *a, const char *c_str)</dt>
<dd>memcmp might make this faster. </dd>
<dt><a class="anchor" id="_todo000050"></a>Global <a class="el" href="group__DBusString.html#gad79c34af55b58f0e8b81ecf11b8694bb">_dbus_string_equal</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *a, const <a class="el" href="structDBusString.html">DBusString</a> *b)</dt>
<dd>memcmp is probably faster </dd>
<dt><a class="anchor" id="_todo000051"></a>Global <a class="el" href="group__DBusString.html#gacf39727ae9eb411b0c4cb3b891588fb0">_dbus_string_equal_len</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *a, const <a class="el" href="structDBusString.html">DBusString</a> *b, int len)</dt>
<dd><p class="startdd">write a unit test</p>
<p class="enddd">memcmp is probably faster </p>
</dd>
<dt><a class="anchor" id="_todo000053"></a>Global <a class="el" href="group__DBusString.html#ga2095c2a797ae245521a7588b32279110">_dbus_string_equal_substring</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *a, int a_start, int a_len, const <a class="el" href="structDBusString.html">DBusString</a> *b, int b_start)</dt>
<dd><p class="startdd">write a unit test</p>
<p class="enddd">memcmp is probably faster </p>
</dd>
<dt><a class="anchor" id="_todo000049"></a>Global <a class="el" href="group__DBusString.html#ga8b7fc22e6738173e1b2cef4b91b9c3c1">_dbus_string_pop_line</a>  (<a class="el" href="structDBusString.html">DBusString</a> *source, <a class="el" href="structDBusString.html">DBusString</a> *dest)</dt>
<dd>owen correctly notes that this is a stupid function (it was written purely for test code, e.g. dbus-message-builder.c). Probably should be enforced as test code only with ifdef DBUS_ENABLE_EMBEDDED_TESTS </dd>
<dt><a class="anchor" id="_todo000055"></a>Global <a class="el" href="group__DBusString.html#gaa4324cd667e21beb31a5481cb0c12b6d">_dbus_string_validate_ascii</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *str, int start, int len)</dt>
<dd>this is inconsistent with most of <a class="el" href="structDBusString.html">DBusString</a> in that it allows a start,len range that extends past the string end. </dd>
<dt><a class="anchor" id="_todo000057"></a>Global <a class="el" href="group__DBusString.html#ga199d0fc00ee3cd0300a1b3870d7986a3">_dbus_string_validate_nul</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *str, int start, int len)</dt>
<dd>this is inconsistent with most of <a class="el" href="structDBusString.html">DBusString</a> in that it allows a start,len range that extends past the string end. </dd>
<dt><a class="anchor" id="_todo000056"></a>Global <a class="el" href="group__DBusString.html#ga65f0f04b7c9371406fc87343f691e8da">_dbus_string_validate_utf8</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *str, int start, int len)</dt>
<dd>this is inconsistent with most of <a class="el" href="structDBusString.html">DBusString</a> in that it allows a start,len range that extends past the string end. </dd>
<dt><a class="anchor" id="_todo000065"></a>Global <a class="el" href="group__DBusTransportUnix.html#gada3df30a229b4d29ccf30af83bd88fcc">_dbus_transport_new_for_domain_socket</a>  (const char *path, dbus_bool_t abstract, <a class="el" href="structDBusError.html" title="Object representing an exception. ">DBusError</a> *error)</dt>
<dd>once we add a way to escape paths in a dbus address, this function needs to do escaping. </dd>
<dt><a class="anchor" id="_todo000066"></a>Global <a class="el" href="group__DBusTransport.html#gabe774b134a4bf8c8fc09e6186470874f">_dbus_transport_try_to_authenticate</a>  (<a class="el" href="structDBusTransport.html" title="Object representing a transport such as a socket. ">DBusTransport</a> *transport)</dt>
<dd>we drop connection-&gt;mutex when calling the unix_user_function, and windows_user_function, which may not be safe really. </dd>
<dt><a class="anchor" id="_todo000016"></a>Global <a class="el" href="group__DBusMarshal.html#gaa4057610b3d9e81fed212c17f6599516">_dbus_type_reader_delete</a>  (<a class="el" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values. ">DBusTypeReader</a> *reader, const <a class="el" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values. ">DBusTypeReader</a> *realign_root)</dt>
<dd>for now this does not delete the typecodes associated with the value, so this function should only be used for array elements. </dd>
<dt><a class="anchor" id="_todo000014"></a>Global <a class="el" href="group__DBusMarshal.html#gaaf11ca429434c2c280f5fad34ed95204">_dbus_type_reader_set_basic</a>  (<a class="el" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values. ">DBusTypeReader</a> *reader, const void *value, const <a class="el" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values. ">DBusTypeReader</a> *realign_root)</dt>
<dd><p class="startdd"><a class="el" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values. ">DBusTypeReader</a> currently takes "const" versions of the type and value strings, and this function modifies those strings by casting away the const, which is of course bad if we want to get picky. (To be truly clean you'd have an object which contained the type and value strings and set_basic would be a method on that object... this would also make <a class="el" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values. ">DBusTypeReader</a> the same thing as DBusTypeMark. But since <a class="el" href="structDBusMessage.html" title="Internals of DBusMessage. ">DBusMessage</a> is effectively that object for D-Bus it doesn't seem worth creating some random object.)</p>
<p class="enddd">optimize this by only rewriting until the old and new values are at the same alignment. Frequently this should result in only replacing the value that's immediately at hand. </p>
</dd>
<dt><a class="anchor" id="_todo000022"></a>Global <a class="el" href="group__DBusMarshal.html#gaab91a04fa2a96b8ce8843beae7327cd0">_dbus_validate_bus_name</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *str, int start, int len)</dt>
<dd>this is inconsistent with most of <a class="el" href="structDBusString.html">DBusString</a> in that it allows a start,len range that extends past the string end. </dd>
<dt><a class="anchor" id="_todo000023"></a>Global <a class="el" href="group__DBusMarshal.html#ga0d034ebf7eb41cede67c86757ce22261">_dbus_validate_bus_namespace</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *str, int start, int len)</dt>
<dd>this is inconsistent with most of <a class="el" href="structDBusString.html">DBusString</a> in that it allows a start,len range that extends past the string end. </dd>
<dt><a class="anchor" id="_todo000021"></a>Global <a class="el" href="group__DBusMarshal.html#ga6d8075f3b60e2e71aad061aa44b120fe">_dbus_validate_error_name</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *str, int start, int len)</dt>
<dd>this is inconsistent with most of <a class="el" href="structDBusString.html">DBusString</a> in that it allows a start,len range that extends past the string end. </dd>
<dt><a class="anchor" id="_todo000019"></a>Global <a class="el" href="group__DBusMarshal.html#ga0ad919783f887a9b6f428e262beaeed9">_dbus_validate_interface</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *str, int start, int len)</dt>
<dd>this is inconsistent with most of <a class="el" href="structDBusString.html">DBusString</a> in that it allows a start,len range that extends past the string end. </dd>
<dt><a class="anchor" id="_todo000020"></a>Global <a class="el" href="group__DBusMarshal.html#gaf647272768029cb23a4e0d3f493587da">_dbus_validate_member</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *str, int start, int len)</dt>
<dd>this is inconsistent with most of <a class="el" href="structDBusString.html">DBusString</a> in that it allows a start,len range that extends past the string end. </dd>
<dt><a class="anchor" id="_todo000017"></a>Global <a class="el" href="group__DBusMarshal.html#ga616ba4a0280b10222930aedadb7ea8d9">_dbus_validate_path</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *str, int start, int len)</dt>
<dd><p class="startdd">this is inconsistent with most of <a class="el" href="structDBusString.html">DBusString</a> in that it allows a start,len range that extends past the string end.</p>
<p class="enddd">change spec to disallow more things, such as spaces in the path name </p>
</dd>
<dt><a class="anchor" id="_todo000024"></a>Global <a class="el" href="group__DBusMarshal.html#ga8d7aa58f6484d5d24f275dd65f101676">_dbus_validate_signature</a>  (const <a class="el" href="structDBusString.html">DBusString</a> *str, int start, int len)</dt>
<dd>this is inconsistent with most of <a class="el" href="structDBusString.html">DBusString</a> in that it allows a start,len range that extends past the string end. </dd>
<dt><a class="anchor" id="_todo000068"></a>Global <a class="el" href="group__DBusWatchInternals.html#ga75620808f4d2245914012a41e3b82f3c">_dbus_watch_set_handler</a>  (<a class="el" href="structDBusWatch.html" title="Implementation of DBusWatch. ">DBusWatch</a> *watch, DBusWatchHandler handler, void *data, DBusFreeFunction free_data_function)</dt>
<dd>this function only exists because of the weird way connection watches are done, see the note in docs for <a class="el" href="group__DBusConnectionInternals.html#ga12756797bd5c1918aa065f9c37ed7bba" title="A callback for use with dbus_watch_new() to create a DBusWatch. ">_dbus_connection_handle_watch()</a>. </dd>
<dt><a class="anchor" id="_todo000011"></a>Global <a class="el" href="group__DBusConnection.html#gae00f581e5487408cb294bf71826aff86">dbus_connection_add_filter</a>  (<a class="el" href="structDBusConnection.html" title="Implementation details of DBusConnection. ">DBusConnection</a> *connection, DBusHandleMessageFunction function, void *user_data, DBusFreeFunction free_data_function)</dt>
<dd>we don't run filters on messages while blocking without entering the main loop, since filters are run as part of <a class="el" href="group__DBusConnection.html#ga66ba7df50d75f4bda6b6e942430b81c7" title="Processes any incoming data. ">dbus_connection_dispatch()</a>. This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you're trying to filter METHOD_RETURN for some reason. </dd>
<dt><a class="anchor" id="_todo000009"></a>Global <a class="el" href="group__DBusConnection.html#ga66ba7df50d75f4bda6b6e942430b81c7">dbus_connection_dispatch</a>  (<a class="el" href="structDBusConnection.html" title="Implementation details of DBusConnection. ">DBusConnection</a> *connection)</dt>
<dd>some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY </dd>
<dt><a class="anchor" id="_todo000010"></a>Global <a class="el" href="group__DBusConnection.html#ga2b3cb488f1922aeecdeafdcb110e91a8">dbus_connection_get_windows_user</a>  (<a class="el" href="structDBusConnection.html" title="Implementation details of DBusConnection. ">DBusConnection</a> *connection, char **windows_sid_p)</dt>
<dd>We would like to be able to say "You can ask the bus to tell you the user of another connection though if you like; this is done with dbus_bus_get_windows_user()." But this has to be implemented in bus/driver.c and <a class="el" href="dbus-bus_8c_source.html">dbus/dbus-bus.c</a>, and is pointless anyway since on Windows we only use the session bus for now. </dd>
<dt><a class="anchor" id="_todo000028"></a>Global <a class="el" href="group__DBusMessage.html#ga591f3aab5dd2c87e56e05423c2a671d9">dbus_message_append_args</a>  (<a class="el" href="structDBusMessage.html" title="Internals of DBusMessage. ">DBusMessage</a> *message, int first_arg_type,...)</dt>
<dd><p class="startdd">support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays</p>
<p class="enddd">If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. </p>
</dd>
<dt><a class="anchor" id="_todo000030"></a>Global <a class="el" href="group__DBusMessage.html#ga106e541001d6b884d1c3cea6044693ab">dbus_message_append_args_valist</a>  (<a class="el" href="structDBusMessage.html" title="Internals of DBusMessage. ">DBusMessage</a> *message, int first_arg_type, va_list var_args)</dt>
<dd>for now, if this function fails due to OOM it will leave the message half-written and you have to discard the message and start over. </dd>
<dt><a class="anchor" id="_todo000027"></a>Global <a class="el" href="group__DBusMessage.html#ga4bed3858b3b48ec7c86d9fc56a6ce372">dbus_message_copy</a>  (const <a class="el" href="structDBusMessage.html" title="Internals of DBusMessage. ">DBusMessage</a> *message)</dt>
<dd>This function can't be used in programs that try to recover from OOM errors. </dd>
<dt><a class="anchor" id="_todo000031"></a>Global <a class="el" href="group__DBusMessage.html#gad8953f53ceea7de81cde792e3edd0230">dbus_message_get_args</a>  (<a class="el" href="structDBusMessage.html" title="Internals of DBusMessage. ">DBusMessage</a> *message, <a class="el" href="structDBusError.html" title="Object representing an exception. ">DBusError</a> *error, int first_arg_type,...)</dt>
<dd>support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays </dd>
<dt><a class="anchor" id="_todo000038"></a>Global <a class="el" href="group__DBusMessage.html#gaf2b5b3319da838b1f1b360c04a33f153">dbus_message_get_path_decomposed</a>  (<a class="el" href="structDBusMessage.html" title="Internals of DBusMessage. ">DBusMessage</a> *message, char ***path)</dt>
<dd>this could be optimized by using the len from the message instead of calling strlen() again </dd>
<dt><a class="anchor" id="_todo000034"></a>Global <a class="el" href="group__DBusMessage.html#ga17491f3b75b3203f6fc47dcc2e3b221b">dbus_message_iter_append_basic</a>  (<a class="el" href="structDBusMessageIter.html" title="DBusMessageIter struct; contains no public fields. ">DBusMessageIter</a> *iter, int type, const void *value)</dt>
<dd>If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. </dd>
<dt><a class="anchor" id="_todo000035"></a>Global <a class="el" href="group__DBusMessage.html#ga6e2d1e936c3c61fe00d80a3f22fd5e76">dbus_message_iter_append_fixed_array</a>  (<a class="el" href="structDBusMessageIter.html" title="DBusMessageIter struct; contains no public fields. ">DBusMessageIter</a> *iter, int element_type, const void *value, int n_elements)</dt>
<dd>If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. </dd>
<dt><a class="anchor" id="_todo000037"></a>Global <a class="el" href="group__DBusMessage.html#gaf00482f63d4af88b7851621d1f24087a">dbus_message_iter_close_container</a>  (<a class="el" href="structDBusMessageIter.html" title="DBusMessageIter struct; contains no public fields. ">DBusMessageIter</a> *iter, <a class="el" href="structDBusMessageIter.html" title="DBusMessageIter struct; contains no public fields. ">DBusMessageIter</a> *sub)</dt>
<dd>If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. </dd>
<dt><a class="anchor" id="_todo000032"></a>Global <a class="el" href="group__DBusMessage.html#gab8ff47649497b3e0b93a2289f5d3eb23">dbus_message_iter_get_array_len</a>  (<a class="el" href="structDBusMessageIter.html" title="DBusMessageIter struct; contains no public fields. ">DBusMessageIter</a> *iter)</dt>
<dd>introduce a variant of this get_n_elements that returns the number of elements, though with a non-fixed array it will not be very efficient, so maybe it's not good. </dd>
<dt><a class="anchor" id="_todo000033"></a>Global <a class="el" href="group__DBusMessage.html#gaf733047c467ce21f4a53b65a388f1e9d">dbus_message_iter_init_append</a>  (<a class="el" href="structDBusMessage.html" title="Internals of DBusMessage. ">DBusMessage</a> *message, <a class="el" href="structDBusMessageIter.html" title="DBusMessageIter struct; contains no public fields. ">DBusMessageIter</a> *iter)</dt>
<dd>If appending any of the arguments fails due to lack of memory, the message is hosed and you have to start over building the whole message. </dd>
<dt><a class="anchor" id="_todo000036"></a>Global <a class="el" href="group__DBusMessage.html#ga943150f4e87fd8507da224d22c266100">dbus_message_iter_open_container</a>  (<a class="el" href="structDBusMessageIter.html" title="DBusMessageIter struct; contains no public fields. ">DBusMessageIter</a> *iter, int type, const char *contained_signature, <a class="el" href="structDBusMessageIter.html" title="DBusMessageIter struct; contains no public fields. ">DBusMessageIter</a> *sub)</dt>
<dd>If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. </dd>
<dt><a class="anchor" id="_todo000026"></a>Global <a class="el" href="group__DBusMessage.html#ga707a27881820f964e3606bc906a47978">dbus_message_new_error_printf</a>  (<a class="el" href="structDBusMessage.html" title="Internals of DBusMessage. ">DBusMessage</a> *reply_to, const char *error_name, const char *error_format,...)</dt>
<dd>add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) </dd>
<dt><a class="anchor" id="_todo000045"></a>Global <a class="el" href="group__DBusPendingCall.html#ga67b99f749a7f477c7b5d70f2acee5452">dbus_pending_call_block</a>  (<a class="el" href="structDBusPendingCall.html" title="Implementation details of DBusPendingCall - all fields are private. ">DBusPendingCall</a> *pending)</dt>
<dd>when you start blocking, the timeout is reset, but it should really only use time remaining since the pending call was created. This requires storing timestamps instead of intervals in the timeout </dd>
<dt><a class="anchor" id="_todo000001"></a>Module <a class="el" href="group__DBusAuth.html">DBusAuth</a>  </dt>
<dd><p class="startdd">some SASL profiles require sending the empty string as a challenge/response, but we don't currently allow that in our protocol.</p>
<p>right now sometimes both ends will block waiting for input from the other end, e.g. if there's an error during DBUS_COOKIE_SHA1.</p>
<p>the cookie keyring needs to be cached globally not just per-auth (which raises threadsafety issues too)</p>
<p class="enddd">grep FIXME in <a class="el" href="dbus-auth_8c_source.html">dbus-auth.c</a>  </p>
</dd>
<dt><a class="anchor" id="_todo000006"></a>Module <a class="el" href="group__DBusBus.html">DBusBus</a>  </dt>
<dd>right now the default address of the system bus is hardcoded, so if you change it in the global config file suddenly you have to set DBUS_SYSTEM_BUS_ADDRESS env variable. Might be nice if the client lib somehow read the config file, or if the bus on startup somehow wrote out its address to a well-known spot, but might also not be worth it.  </dd>
<dt><a class="anchor" id="_todo000063"></a>Global <a class="el" href="group__DBusSysdeps.html#ga24015a2f75b94c1307360755ce97f869">DBusGUID</a>  </dt>
<dd>rename to UUID instead of GUID  </dd>
<dt><a class="anchor" id="_todo000012"></a>Module <a class="el" href="group__DBusKeyring.html">DBusKeyring</a>  </dt>
<dd>there's a memory leak on some codepath in here, I saw it once when running make check - probably some specific initial cookies present in the cookie file, then depending on what we do with them.  </dd>
<dt><a class="anchor" id="_todo000025"></a>Global <a class="el" href="group__DBusMessageInternals.html#gab6a849ea8db3714da7a161b4f6a6f0fb">DBusMessageLoader</a>  </dt>
<dd>write tests for break-loader that a) randomly delete header fields and b) set string fields to zero-length and other funky values. </dd>
<dt><a class="anchor" id="_todo000046"></a>Module <a class="el" href="group__DBusServer.html">DBusServer</a>  </dt>
<dd><p class="startdd">Thread safety hasn't been tested much for <a class="el" href="structDBusServer.html" title="Internals of DBusServer object. ">DBusServer</a> </p>
<p class="enddd">Need notification to apps of disconnection, may matter for some transports  </p>
</dd>
<dt><a class="anchor" id="_todo000048"></a>Module <a class="el" href="group__DBusString.html">DBusString</a>  </dt>
<dd><a class="el" href="structDBusString.html">DBusString</a> needs a lot of cleaning up; some of the API is no longer used, and the API is pretty inconsistent. In particular all the "append" APIs, especially those involving alignment but probably lots of them, are no longer used by the marshaling code which always does "inserts" now.  </dd>
<dt><a class="anchor" id="_todo000039"></a>Global <a class="el" href="group__DBusMessageInternals.html#gacbe0bfe7a9551ab0489a0ec9aba6e94e">INITIAL_LOADER_DATA_LEN</a>  </dt>
<dd>this should be based on min header size plus some average body size, or something. Or rather, the min header size only, if we want to try to read only the header, store that in a <a class="el" href="structDBusMessage.html" title="Internals of DBusMessage. ">DBusMessage</a>, then read only the body and store that, etc., depends on how we optimize <a class="el" href="group__DBusMessageInternals.html#gae77f064b8034189a955d5be982d2fbdb" title="Gets the buffer to use for reading data from the network. ">_dbus_message_loader_get_buffer()</a> and what the exact message format is. </dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
